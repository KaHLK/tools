<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Extremely fast, lossless, and error tolerant JavaScript Parser."><meta name="keywords" content="rust, rustlang, rust-lang, rome_js_parser"><title>rome_js_parser - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../rome_js_parser/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../rome_js_parser/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">Crate rome_js_parser</a></h2><div class="sidebar-elems"><div class="block"><ul><li class="version">Version 0.0.0</li><li><a id="all-types" href="all.html">All Items</a></li></div></ul><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section><div id="sidebar-vars" data-name="rome_js_parser" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../rome_js_parser/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">rome_js_parser</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/rome_js_parser/lib.rs.html#1-217">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Extremely fast, lossless, and error tolerant JavaScript Parser.</p>
<p>The parser uses an abstraction over non-whitespace tokens.
This allows us to losslessly or lossly parse code without requiring explicit handling of whitespace.
The parser yields events, not an AST, the events are resolved into untyped syntax nodes, which can then
be casted into a typed AST.</p>
<p>The parser is able to produce a valid AST from <strong>any</strong> source code.
Erroneous productions are wrapped into <code>ERROR</code> syntax nodes, the original source code
is completely represented in the final syntax nodes.</p>
<p>You probably do not want to use the parser struct, unless you want to parse fragments of Js source code or make your own productions.
Instead use functions such as <a href="fn.parse_script.html" title="parse_script">parse_script</a>, <a href="fn.parse_module.html" title="parse_module">parse_module</a>, and [] which offer abstracted versions for parsing.</p>
<p>Notable features of the parser are:</p>
<ul>
<li>Extremely fast parsing and lexing through the extremely fast lexer.</li>
<li>Ability to do Lossy or Lossless parsing on demand without explicit whitespace handling.</li>
<li>Customizable, able to parse any fragments of JS code at your discretion.</li>
<li>Completely error tolerant, able to produce an AST from any source code.</li>
<li>Zero cost for converting untyped nodes to a typed AST.</li>
<li>Ability to go from AST to SyntaxNodes to SyntaxTokens to source code and back very easily with nearly zero cost.</li>
<li>Very easy tree traversal through <a href="../rome_rowan/syntax/node/struct.SyntaxNode.html"><code>SyntaxNode</code></a>.</li>
<li>Descriptive errors with multiple labels and notes.</li>
<li>Very cheap cloning, cloning an ast node or syntax node is the cost of adding a reference to an Rc.</li>
<li>Cheap incremental reparsing of changed text.</li>
</ul>
<p>The crate further includes utilities such as:</p>
<ul>
<li>ANSI syntax highlighting of nodes or text through <code>lexer</code>.</li>
</ul>
<p>It is inspired by the rust analyzer parser but adapted for JavaScript.</p>
<h2 id="syntax-nodes-vs-ast-nodes"><a href="#syntax-nodes-vs-ast-nodes">Syntax Nodes vs AST Nodes</a></h2>
<p>The crate relies on a concept of untyped <a href="../rome_js_syntax/syntax_node/type.JsSyntaxNode.html" title="rome_js_syntax::JsSyntaxNode">rome_js_syntax::JsSyntaxNode</a>s vs typed <a href="../rome_rowan/ast/trait.AstNode.html" title="rome_rowan::AstNode">rome_rowan::AstNode</a>s.
Syntax nodes represent the syntax tree in an untyped way. They represent a location in an immutable
tree with two pointers. The syntax tree is composed of <a href="../rome_js_syntax/syntax_node/type.JsSyntaxNode.html" title="rome_js_syntax::JsSyntaxNode">rome_js_syntax::JsSyntaxNode</a>s and <a href="../rome_js_syntax/syntax_node/type.JsSyntaxToken.html" title="rome_js_syntax::JsSyntaxToken">rome_js_syntax::JsSyntaxToken</a>s in a nested
tree structure. Each node can have parents, siblings, children, descendants, etc.</p>
<p><a href="../rome_rowan/ast/trait.AstNode.html" title="rome_rowan::AstNode">rome_rowan::AstNode</a>s represent a typed version of a syntax node. They have the same exact representation as syntax nodes
therefore a conversion between either has zero runtime cost. Every piece of data of an ast node is optional,
this is due to the fact that the parser is completely error tolerant.</p>
<p>Each representation has its advantages:</p>
<h4 id="syntaxnodes"><a href="#syntaxnodes">SyntaxNodes</a></h4>
<ul>
<li>Very simple traversing of the syntax tree through functions on them.</li>
<li>Easily able to convert to underlying text, range, or tokens.</li>
<li>Contain all whitespace bound to the underlying production (in the case of lossless parsing).</li>
<li>Can be easily converted into its typed representation with zero cost.</li>
<li>Can be turned into a pretty representation with fmt debug.</li>
</ul>
<h4 id="ast-nodes"><a href="#ast-nodes">AST Nodes</a></h4>
<ul>
<li>Easy access to properties of the underlying production.</li>
<li>Zero cost conversion to a syntax node.</li>
</ul>
<p>In conclusion, the use of both representations means we are not constrained to acting through
typed nodes. Which makes traversal hard and you often have to resort to autogenerated visitor patterns.
AST nodes are simply a way to easily access subproperties of a syntax node.event;</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="syntax/index.html" title="rome_js_parser::syntax mod">syntax</a></div><div class="item-right docblock-short"><p>The Js syntax itself and parser functions.</p>
</div></div></div><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="macro" href="macro.token_set.html" title="rome_js_parser::token_set macro">token_set</a></div><div class="item-right docblock-short"><p>Utility macro for making a new token set</p>
</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LosslessTreeSink.html" title="rome_js_parser::LosslessTreeSink struct">LosslessTreeSink</a></div><div class="item-right docblock-short"><p>Structure for converting events to a syntax tree representation, while preserving whitespace.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Parse.html" title="rome_js_parser::Parse struct">Parse</a></div><div class="item-right docblock-short"><p>A utility struct for managing the result of a parser job</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TokenSet.html" title="rome_js_parser::TokenSet struct">TokenSet</a></div><div class="item-right docblock-short"></div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Event.html" title="rome_js_parser::Event enum">Event</a></div><div class="item-right docblock-short"><p>Events emitted by the Parser, these events are later
made into a syntax tree with <code>process</code> into TreeSink.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.JsSyntaxFeature.html" title="rome_js_parser::JsSyntaxFeature enum">JsSyntaxFeature</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.LexContext.html" title="rome_js_parser::LexContext enum">LexContext</a></div><div class="item-right docblock-short"><p>Context in which the lexer should lex the next token</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ReLexContext.html" title="rome_js_parser::ReLexContext enum">ReLexContext</a></div><div class="item-right docblock-short"><p>Context in which the <a href="enum.LexContext.html" title="LexContext">LexContext</a>’s current should be re-lexed.</p>
</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.TreeSink.html" title="rome_js_parser::TreeSink trait">TreeSink</a></div><div class="item-right docblock-short"><p>An abstraction for syntax tree implementations</p>
</div></div></div><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse.html" title="rome_js_parser::parse fn">parse</a></div><div class="item-right docblock-short"><p>Parses the provided string as a EcmaScript program using the provided syntax features.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_common.html" title="rome_js_parser::parse_common fn">parse_common</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_expression.html" title="rome_js_parser::parse_expression fn">parse_expression</a></div><div class="item-right docblock-short"><p>Losslessly Parse text into an expression <a href="struct.Parse.html"><code>Parse</code></a> which can then be turned into an untyped root <a href="../rome_js_syntax/syntax_node/type.JsSyntaxNode.html"><code>JsSyntaxNode</code></a>.
Or turned into a typed <a href="../rome_js_syntax/generated/nodes/struct.JsExpressionSnipped.html"><code>JsExpressionSnipped</code></a> with <a href="struct.Parse.html#method.tree"><code>tree</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_module.html" title="rome_js_parser::parse_module fn">parse_module</a></div><div class="item-right docblock-short"><p>Same as <code>parse_text</code> but configures the parser to parse an ECMAScript module instead of a script</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_script.html" title="rome_js_parser::parse_script fn">parse_script</a></div><div class="item-right docblock-short"><p>Parse text into a <a href="struct.Parse.html"><code>Parse</code></a> which can then be turned into an untyped root <a href="../rome_js_syntax/syntax_node/type.JsSyntaxNode.html"><code>JsSyntaxNode</code></a>.
Or turned into a typed <a href="../rome_js_syntax/generated/nodes/struct.JsScript.html"><code>JsScript</code></a> with <a href="struct.Parse.html#method.tree"><code>tree</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.process.html" title="rome_js_parser::process fn">process</a></div><div class="item-right docblock-short"><p>Generate the syntax tree with the control of events.</p>
</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.ParseDiagnostic.html" title="rome_js_parser::ParseDiagnostic type">ParseDiagnostic</a></div><div class="item-right docblock-short"><p>The type of error emitted by the parser, this includes warnings, notes, and errors.
It also includes labels and possibly notes</p>
</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="rome_js_parser" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.62.0 (a8314ef7d 2022-06-27)" ></div>
</body></html>